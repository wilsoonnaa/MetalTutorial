title: 3. Hello Triangle
# Rendering a Triangle to the Screen
In this chapter, we'll finally be getting to render something to the screen! Exciting stuff. We're going to start with something simple: a triangle!
````cpp hl_lines="12 13 14 15 17 18 19 25 27 28 29 30 31"
// mtl_engine.hpp
class MTLEngine {
public:
    void init();
    void run();
    void cleanup();

private:
    void initDevice();
    void initWindow();
    
    void createDefaultLibrary();
    void createCommandQueue();
    void createRenderPipeline();
    void createTriangle();
    
    void encodeRenderCommand(MTL::RenderCommandEncoder* renderEncoder);
    void sendRenderCommand();
    void draw();
    
    MTL::Device* metalDevice;
    GLFWwindow* glfwWindow;
    NSWindow* metalWindow;
    CAMetalLayer* metalLayer;
    CA::MetalDrawable* metalDrawable;
    
    MTL::Library* metalDefaultLibrary;
    MTL::CommandQueue* metalCommandQueue;
    MTL::CommandBuffer* metalCommandBuffer;
    MTL::RenderPipelineState* metalRenderPSO;
    MTL::Buffer* triangleVertexBuffer;
};
````
Here are the member functions and variables that we'll be adding to our MTLEngine. It may seem like quite a lot of stuff is required to render a simple triangle, and in the grand scheme of things it is. But, I assure you, the effort required in Metal is far less than the other modern Graphics APIs, being DirectX12 and Vulkan. In Vulkan, it typically takes about 1000 lines of code to render a single triangle ðŸ˜±. With Metal, it will only take us about 100 lines of code to get there, and we've already got 40 of them :). Get your boots strapped ladies and gentleman, it's time to dive in.

The first addition is `createDefaultLibrary()`:
````cpp linenums="7" hl_lines="6"
// mtl_engine.mm
void MTLEngine::init() {
    initDevice();
    initWindow();
    
    createDefaultLibrary();
}
...
````
````cpp linenums="51"
...
void MTLEngine::createDefaultLibrary() {
    metalDefaultLibrary = metalDevice->newDefaultLibrary();
    if(!metalDefaultLibrary){
        std::cerr << "Failed to load default library.";
        std::exit(-1);
    }
}
````
This goes into our `init()` function after we initialize our Metal device and GLFW window. The first thing we're going to do is access our `metalDevice` to create a new default library. Xcode automatically compiles all Metal source files (ending in `.metal`) within an Xcode project into a single default library upon project compilation. In our case, because we're not compiling our Metal source code at runtime, our `MTL::Library*` object will give us access to all of our Metal source code from a single source, making it very simple to access and manage. If for any reason we're unable to load our compiled Metal binaries, we'll exit. If for any reason later on you get any errors here, make sure that your Metal source files are added as compile targets in the `Build Phases` section of the project.

````cpp linenums="7" hl_lines="7"
// mtl_engine.mm
void MTLEngine::init() {
    initDevice();
    initWindow();
    
    createDefaultLibrary();
    createCommandQueue();
}
...
````
````cpp linenums="59"
...
void MTLEngine::createCommandQueue() {
    metalCommandQueue = metalDevice->newCommandQueue();
}
````

