{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Metal","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Metal Tutorial. This tutorial will teach you the basics of the Metal graphics and compute API, and help you understand how to program with it in C++ via the <code>metal-cpp</code> library that Apple has now officially released. The documentation for it is non-existant, and it is missing some key features, so I'll show you how to work around those in the following chapters. This will not necessarily serve as a guide or introduction to Computer Graphics, but more as a way to get up and running with Metal using C++. For those who are completely new, I'll try to go over everything in as much detail as I possibly can, and link to other existing guides for more information when needed. I hope that this can be of use to you. If you'd like to contribute your own content to the tutorial series, or correct any mistakes that I've made, you can find the github repository here.</p>"},{"location":"#metal-documenation-and-other-useful-resources","title":"Metal Documenation and Other Useful Resources","text":"<p>Here are some resources that you may find helpful both while completing these tutorials, as well as when using Metal more generally:</p>"},{"location":"#official-apple-metal-documentation","title":"Official Apple Metal Documentation","text":"<ul> <li>Metal Documentation</li> <li>Metal Specification</li> <li>Creating and Sampling Textures</li> <li>Creating Threads and Threadgroups</li> </ul>"},{"location":"#useful-metal-resources","title":"Useful Metal Resources","text":"<ul> <li>Intro to Metal Compute</li> <li>Constant vs Device Address Space</li> <li>\"Pass by reference\" in Metal</li> <li>Metal Best Practices Guide (Drawables)</li> <li>Metal-CPP discussion reddit</li> </ul>"},{"location":"#computer-graphics-fundamentals","title":"Computer Graphics Fundamentals","text":"<ul> <li>Linear Algebra</li> </ul>"},{"location":"#ray-tracing","title":"Ray Tracing","text":"<ul> <li>GPU Ray-Tracing in One an Afternoon</li> <li>GPU Ray-Tracing in One Weekend</li> <li>CUDA Compute Ray-Tracing</li> <li>GPU Accelerated Path-Tracer (hemispheres/rand)</li> <li>Random Number Generation and Sampling (like on hemisphere)</li> </ul>"},{"location":"Setup/","title":"Setting up Xcode for use with <code>metal-cpp</code>","text":"<p>In order to write Metal code, either for an iOS based device or MacOS, we're pretty much going to need Xcode. Development for Apple devices can be done in other editors, but it is not recommended, as Xcode is created by Apple specifically for development within its ecosystem. If you don't have it already, you can download it for free from the Mac App Store. </p> <p>Metal is designed to be written in a programming language called Objective-C. Objective-C, along with Apple's Swift programming language, are the languages typically used to write macOS and iOS applications. In this tutorial series, however, we're going to be writing our application primarily in C++, as this is the industry standard for writing Computer Graphics related applications, whether it be for real-time rendering in video games, or for CAD software. I say \"primarily\" because we'll actually be using a bit of \"Objective-C++\", which allows us to mix Objective-C code with C++ to make things a little easier for us. Even though Metal is typically written in pure Objective-C, for convenience Apple has released a set of C++ bindings that act as an interface to the the Metal Graphics API, allowing us to write high-performance graphics and compute applications for Apple devices in (almost) pure C++. This wrapper is very light-weight, and acts as a one-to-one translation between the native Objective-C functions calls and C++. You're going to need to download the library here.</p> <p>Once you have downloaded the <code>metal-cpp</code> library, open Xcode and <code>Create a new Xcode project</code>. For this tutorial we're going to be targetting Mac devices, so under the <code>macOS</code> templates, select <code>Command Line Tool</code>. This will set the default language to C++ and give us an empty <code>Hello-World</code> project.</p> <p>The first thing we want to do is drag and drop our freshly downloaded and unzipped 'metal-cpp' folder into our Xcode project.</p> <p></p> <p>Now that we've got it copied over to our project, we need to make sure Xcode can find it. If we head over to the <code>Build Settings</code> section of our project target, under <code>Search Paths</code>, go ahead and add the metal-cpp folder to your header search paths: <pre><code>$(PROJECT_DIR)/metal-cpp\n</code></pre></p> <p></p> <p>The next thing we should do is link with the necessary Apple frameworks to be able to use Metal. Head over to the <code>Build Phases</code> section, and under <code>Link Binary With Libraries</code>, add these three frameworks: <pre><code>Foundation.framework\nMetal.framework\nQuartzCore.framework\n</code></pre></p> <p></p> <p>Now, Metal should be ready to go. Apple's <code>metal-cpp</code> guide tells us that we need to define the <code>metal-cpp</code> implementation in only one of our <code>.cpp</code> files. We're going to create a new file called <code>mtl_implementation.cpp</code> to do this for us, fill it with the necessary <code>define</code> and <code>include</code> statements:</p> <pre><code>//  mtl_implementation.cpp\n#define NS_PRIVATE_IMPLEMENTATION\n#define CA_PRIVATE_IMPLEMENTATION\n#define MTL_PRIVATE_IMPLEMENTATION\n#include &lt;Foundation/Foundation.hpp&gt;\n#include &lt;Metal/Metal.hpp&gt;\n#include &lt;QuartzCore/QuartzCore.hpp&gt;\n</code></pre> <p>Back in our <code>main.cpp</code> file, you add the Metal include, and create a default device:</p> <p><pre><code>//  main.cpp\n#include &lt;Metal/Metal.hpp&gt;\n...\nint main() {\n...\nMTL::Device* device = MTL::CreateSystemDefaultDevice();\n...\n}\n</code></pre> Now, you can build and run: </p> <p>If everything went smoothly, you should see some output in the Xcode console mentioning Metal API Validation and what not. If you don't, make sure you followed all of the steps correctly.</p>"},{"location":"Lesson%201%3A%20Hello%20Triangle/1.%20GLFW/","title":"Setting up GLFW for Window Creation","text":"<p>To use the graphics rendering aspect of Metal, we're going to need a window to render our application to. This is where a cross platform windowing library called <code>GLFW</code> comes in. Typically, it's used in conjunction with the OpenGL graphics API, but we can disable this functionality to be able to use it with Metal. In short, it's going to make window creation, as well as keyboard/mouse/controller input handling really easy for us. MacOS has it's own windowing library that's part of the Cocoa framework, but I'm not familiar with how to use it, and we'll able to setup GLFW and get it to expose the part of Cocoa windowing that we will need in about 5 lines of code.</p> <p>There's a couple of different ways to get GLFW. One way is to download the macOS pre-compiled binaries on the glfw website. If you would prefer to do it this way, make sure to include the glfw <code>include</code> directory in your project, and then like I showed with the <code>metal-cpp</code> library, add this <code>include</code> directory to the header search paths under the <code>Build Settings</code> for your target (i.e. Metal-Guide, or whatever you named it). Then, under <code>Build Phases</code>, add the corresponding static or dynamic library in the <code>Link Binary With Libraries</code> section.</p> <p>Alternatively, you can get it via the <code>brew</code> package manager, which is what I've done. If you don't have <code>brew</code>, you can get it here: brew.sh. It's a very useful tool to have for software development on Mac. It's essentially like <code>apt-get</code> on Debian Linux distros, if you're familiar with that.</p> <p>Once you have brew, you can install glfw with this terminal command: <pre><code>brew install glfw\n</code></pre> Now, we need to add brew's header <code>include</code> directory to our Xcode header search path, so Xcode can find GLFW's header files. </p> <p>If you're not sure what kind of Mac you have, click the \uf8ff logo in the top left of your screen, hit <code>About This Mac</code> and check the Chip type.</p> <p>If you're on an M1 Mac, like I am, you can add this directory under the <code>Build Settings</code> section for your Xcode target: <pre><code>/opt/homebrew/Cellar/glfw/...version_goes_here.../include\n</code></pre> </p> <p>Alternatively, if you have an Intel Mac, brew will install packages to the <code>/usr/local</code> directory. Correspondingly, you can use this directory instead: <pre><code>/usr/local/Cellar/glfw/...version_goes_here.../include\n</code></pre></p> <p>Next, we're going to link with the glfw dynamic library. Under Build Phases, and under <code>Link Binary With Libraries</code>, click the <code>+</code> icon, <code>Add Other</code>, then <code>Add Files...</code>. It will open up a <code>Finder Window</code>: </p> <p>When you have the window open, hold these 3 keys at the same time: <code>Command + Shift + G</code>. If on an M1 Mac: <pre><code>/opt/homebrew/Cellar/glfw/...version_goes_here.../lib\n</code></pre> And if on an Intel Mac: <pre><code>/usr/local/Cellar/glfw/...version_goes_here.../lib\n</code></pre> Select <code>libglfw.3.3.dylib</code>: </p> <p>And you should be all set to use GLFW!</p>"},{"location":"Lesson%201%3A%20Hello%20Triangle/2.%20Hello%20Window/","title":"Setting up our Window","text":"<p>Now that we've setup GLFW, it's time to make a window, as we'll need one before we're able to render anything to our screen. We're going to stash all of our rendering engine logic in a new file we'll call <code>mtl_engine.mm</code>, with the corresponding header <code>mtl_engine.hpp</code>. You might be wondering what the <code>.mm</code> extension is for. This is where the Objective-C I discussed in the <code>Setup</code> section comes in. Essentially, it tells Xcode to allow us to combine C++ and Objective-C code in the same file and compile it. We have to do this, because some of the windowing functions we'll need aren't mapped to the <code>metal-cpp</code> library for some reason, at least at the time of writing this. Critically, we're going to want to change our <code>main.cpp</code> file to <code>main.mm</code> as well.</p> <p>In <code>mtl_engine.hpp</code>, we're first going to include the necessary headers for <code>GLFW</code> and <code>metal-cpp</code>: <pre><code>// mtl_engine.hpp\n#pragma once\n#define GLFW_INCLUDE_NONE\n#import &lt;GLFW/glfw3.h&gt;\n#define GLFW_EXPOSE_NATIVE_COCOA\n#import &lt;GLFW/glfw3native.h&gt;\n#include &lt;Metal/Metal.hpp&gt;\n#include &lt;Metal/Metal.h&gt;\n#include &lt;QuartzCore/CAMetalLayer.hpp&gt;\n#include &lt;QuartzCore/CAMetalLayer.h&gt;\n#include &lt;QuartzCore/QuartzCore.hpp&gt;\n</code></pre> Notice the <code>#define GLFW_EXPOSE_NATIVE_COCOA</code> bit, which is a macro that exposes the native APIs of GLFW for the Cocoa framework on MacOS. It's critical to include that, as it's responsible for our windowing technique!</p> <p>Next, we'll define our Metal Engine class, <code>MTLEngine</code>: <pre><code>// mtl_engine.hpp\nclass MTLEngine {\npublic:\nvoid init();\nvoid run();\nvoid cleanup();\nprivate:\nvoid initDevice();\nvoid initWindow();\nMTL::Device* metalDevice;\nGLFWwindow* glfwWindow;\nNSWindow* metalWindow;\nCAMetalLayer* metalLayer;\n};\n</code></pre> We have three public functions that will be driven in our applications <code>main</code> function, <code>init()</code>, <code>run()</code>, and <code>cleanup()</code>. The <code>init()</code> function will do all of our Window and Metal setup. We're keeping it simple for now, just enough functionality to get a window opened. You'll notice 4 member variables defined at the bottom. The <code>MTL::Device* metalDevice</code> gives us access to our devices GPU, and the plethora of commands that it provides us for rendering and GPU compute work. <code>GLFWwindow* glfwWindow</code> gives us a handle to our GLFWwindow, was well as GLFW's various callback functions, like handling keyboard input and whatnot. Don't worry, we'll dig into it more later. We also have our <code>NSWindow* metalWindow</code> and <code>CAMetalLayer* metalLayer</code>, which are actually our first two Objective-C variables. I'll explain their purpose when we create the window.</p> <p>First, let's take a look at the Engine implementation: <pre><code>//  mtl_engine.mm\n#include \"mtl_engine.hpp\"\nvoid MTLEngine::init() {\ninitDevice();\ninitWindow();\n}\nvoid MTLEngine::run() {\nwhile (!glfwWindowShouldClose(glfwWindow)) {\nglfwPollEvents();\n}\n}\nvoid MTLEngine::cleanup() {\nglfwTerminate();\n}\nvoid MTLEngine::initDevice() {\nmetalDevice = MTL::CreateSystemDefaultDevice();\n}\nvoid MTLEngine::initWindow() {\nglfwInit();\nglfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\nglfwWindow = glfwCreateWindow(800, 600, \"Metal Engine\", NULL, NULL);\nif (!glfwWindow) {\nglfwTerminate();\nexit(EXIT_FAILURE);\n}\nmetalWindow = glfwGetCocoaWindow(glfwWindow);\nmetalLayer = [CAMetalLayer layer];\nmetalLayer.device = (__bridge id&lt;MTLDevice&gt;)metalDevice;\nmetalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;\nmetalWindow.contentView.layer = metalLayer;\nmetalWindow.contentView.wantsLayer = YES;\n}\n</code></pre> It's only 38 lines, so it shouldn't be terribly confusing.</p> <p><pre><code>void MTLEngine::init() {\ninitDevice();\ninitWindow();\n}\n</code></pre> In the <code>init()</code> function, all we're going to be doing is calling Metal and Window setup, so we call our only two setup functions <code>initDevice()</code> and <code>initWindow()</code>. </p> <p><pre><code>void MTLEngine::initDevice() {\nmetalDevice = MTL::CreateSystemDefaultDevice();\n}\n</code></pre> The <code>initDevice()</code> function should feel familiar, we're simply using the <code>metal-cpp</code> library to create our Metal Device (which we used in the Setup) with which we will access all of our Metal rendering functions. </p> <p><pre><code>void MTLEngine::initWindow() {\nglfwInit();\nglfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\nglfwWindow = glfwCreateWindow(800, 600, \"Metal Engine\", NULL, NULL);\nif (!glfwWindow) {\nglfwTerminate();\nexit(EXIT_FAILURE);\n}\nmetalWindow = glfwGetCocoaWindow(glfwWindow);\nmetalLayer = [CAMetalLayer layer];\nmetalLayer.device = (__bridge id&lt;MTLDevice&gt;)metalDevice;\nmetalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;\nmetalWindow.contentView.layer = metalLayer;\nmetalWindow.contentView.wantsLayer = YES;\n}\n</code></pre> The <code>initWindow()</code> function first initializes GLFW, and uses <code>glfwWindowHint()</code> to tell GLFW not to create the OpenGL graphics context, as we're using Metal instead :). We set our <code>glfwWindow</code>, with a window width of <code>800</code> and height of <code>600</code>, and a window name of <code>Metal Engine</code>. If window creation fails, we exit.</p> <p>We then set our <code>metalWindow</code> with a call to <code>glfwGetCocoaWindow()</code>, specifying our <code>glfwWindow</code> as the input. This gives us a reference to the underlying native macOS Cocoa window that <code>GLFW</code> uses underneath for window management. We then use some funky Objective-C syntax <code>[CAMetalLayer layer]</code> to create a metalLayer, as the <code>metal-cpp</code> library does not yet expose all of the parts necessary to do this for some reason. We then set a device, using the <code>__bridge id&lt;MTLDevice&gt;</code> cast to convert from a C++ <code>MTL::Device*</code> pointer to an Objective-C <code>MTLDevice*</code>. We'll eventually end up using this bridging interface a little bit more to convert back and forth between Objective-C and C++ types. We then set the <code>pixelFormat</code> for the <code>metalLayer</code>, and give the <code>metalLayer</code> to the Cocoa window. </p> <p>By setting the layer of the <code>contentView</code> to our <code>metalLayer</code>, we're telling the Cocoa window underneath to use the Metal layer for rendering its content. The Metal layer will provide the low-level access to Metal that we need to perform our graphics rendering. Once the layer of the <code>contentView</code> is set, any content that we draw on the Metal layer will be displayed in the window. Essentially, the Metal layer is acting as what's called the \"framebuffer\". We also specify the <code>wantsLayer</code> property of the window's <code>contentView</code>, to ensure that the Cocoa window underneath will use the <code>metalLayer</code> for rendering its content.</p> <p><pre><code>void MTLEngine::run() {\nwhile (!glfwWindowShouldClose(glfwWindow)) {\nglfwPollEvents();\n}\n}\n</code></pre> Next, we have the <code>run()</code> function, which will eventually be our main program loop, where we'll handle our window updates and draw to the screen. The loop continues until <code>glfwWindowShouldClose(glfwWindow)</code> returns true, which for now will only happen when you hit the red close button at the top of the window. Every iteration of the loop, we'll need to call <code>glfwPollEvents()</code>, which we'll eventually use for handling keyboard input. If you don't include it now, the window won't launch!</p> <p><pre><code>void MTLEngine::cleanup() {\nglfwTerminate();\n}\n</code></pre> Our last function is the <code>cleanup()</code> function, where we'll eventually be handling our de-initiallisation and de-allocation of resources upon program close. For now, this will just include one command, <code>glfwTerminate()</code>.</p> <p>In order to instantiate our <code>MTLEngine</code>, head in to <code>main.mm</code> include the <code>mtl_engine.hpp</code> header, and create the engine: <pre><code>//  main.mm\n#include \"mtl_engine.hpp\"\nint main() {\nMTLEngine engine;\nengine.init();\nengine.run();\nengine.cleanup();\nreturn 0;\n}\n</code></pre></p> <p>If you build and run, you should get a beautiful blank looking window: </p>"},{"location":"Lesson%201%3A%20Hello%20Triangle/3.%20Hello%20Triangle/","title":"Rendering a Triangle to the Screen","text":"<p>In this chapter, we'll finally be getting to render something to the screen! Exciting stuff. We're going to start with something simple: a triangle! <pre><code>// mtl_engine.hpp\nclass MTLEngine {\npublic:\nvoid init();\nvoid run();\nvoid cleanup();\nprivate:\nvoid initDevice();\nvoid initWindow();\nvoid createDefaultLibrary();\nvoid createCommandQueue();\nvoid createRenderPipeline();\nvoid createTriangle();\nvoid encodeRenderCommand(MTL::RenderCommandEncoder* renderEncoder);\nvoid sendRenderCommand();\nvoid draw();\nMTL::Device* metalDevice;\nGLFWwindow* glfwWindow;\nNSWindow* metalWindow;\nCAMetalLayer* metalLayer;\nCA::MetalDrawable* metalDrawable;\nMTL::Library* metalDefaultLibrary;\nMTL::CommandQueue* metalCommandQueue;\nMTL::CommandBuffer* metalCommandBuffer;\nMTL::RenderPipelineState* metalRenderPSO;\nMTL::Buffer* triangleVertexBuffer;\n};\n</code></pre> Here are the member functions and variables that we'll be adding to our MTLEngine. It may seem like quite a lot of stuff is required to render a simple triangle, and in the grand scheme of things it is. But, I assure you, the effort required in Metal is far less than the other modern Graphics APIs, being DirectX12 and Vulkan. In Vulkan, it typically takes about 1000 lines of code to render a single triangle \ud83d\ude31. With Metal, it will only take us about 100 lines of code to get there, and we've already got 40 of them :). Get your boots strapped ladies and gentleman, it's time to dive in.</p> <p>The first addition is <code>createDefaultLibrary()</code>: <pre><code>// mtl_engine.mm\nvoid MTLEngine::init() {\ninitDevice();\ninitWindow();\ncreateDefaultLibrary();\n}\n...\n</code></pre> <pre><code>...\nvoid MTLEngine::createDefaultLibrary() {\nmetalDefaultLibrary = metalDevice-&gt;newDefaultLibrary();\nif(!metalDefaultLibrary){\nstd::cerr &lt;&lt; \"Failed to load default library.\";\nstd::exit(-1);\n}\n}\n</code></pre> This goes into our <code>init()</code> function after we initialize our Metal device and GLFW window. The first thing we're going to do is access our <code>metalDevice</code> to create a new default library. Xcode automatically compiles all Metal source files (ending in <code>.metal</code>) within an Xcode project into a single default library upon project compilation. In our case, because we're not compiling our Metal source code at runtime, our <code>MTL::Library*</code> object will give us access to all of our Metal source code from a single source, making it very simple to access and manage. If for any reason we're unable to load our compiled Metal binaries, we'll exit. If for any reason later on you get any errors here, make sure that your Metal source files are added as compile targets in the <code>Build Phases</code> section of the project.</p> <p><pre><code>// mtl_engine.mm\nvoid MTLEngine::init() {\ninitDevice();\ninitWindow();\ncreateDefaultLibrary();\ncreateCommandQueue();\n}\n...\n</code></pre> <pre><code>...\nvoid MTLEngine::createCommandQueue() {\nmetalCommandQueue = metalDevice-&gt;newCommandQueue();\n}\n</code></pre></p>"}]}