title: 3. Textures
comments: true

# Handling Window Resizing

Before we jump into the fun of adding textures, there's one thing I'd like to add, and that is window resizing. Currently when we resize the window, the resolution of our `metalLayer.drawableSize` will not be updated. To handle this, we'll first define two new functions in our `MTLEngine` class:

````cpp title="mtl_engine.hpp"
class MTLEngine {
...
    static void frameBufferSizeCallback(GLFWwindow *window, int width, int height);
    void resizeFrameBuffer(int width, int height);
...
};
````
And then we'll actually implement them:
````cpp hl_lines="12 13" title="mtl_engine.cpp"
void MTLEngine::frameBufferSizeCallback(GLFWwindow *window, int width, int height) {
    MTLEngine* engine = (MTLEngine*)glfwGetWindowUserPointer(window);
    engine->resizeFrameBuffer(width, height);
}

void MTLEngine::resizeFrameBuffer(int width, int height) {
    metalLayer.drawableSize = CGSizeMake(width, height);
}

void MTLEngine::initWindow() {
    ...
    glfwSetWindowUserPointer(glfwWindow, this);
    glfwSetFramebufferSizeCallback(glfwWindow, frameBufferSizeCallback);
    ...
}
````
GLFW gives us the ability to define a callback function for when the window is resized. It populates the `GLFWwindow*`, `width`, and `height` automatically for us. One issue is that if the callback function is created as a member function in a class, it's required to be static. Normally, this would be an issue, as we want to update the `drawableSize` property of our `metalLayer` variable, which is non-static. We can solve this problem by using the `glfwSetWindowUserPointer()` and `glfwGetWindowUserPointer()` functions provided by GLFW. We can store a pointer to our `MTLEngine` instance in the GLFW window, then retrieve it in the static callback function to access our non-static `resizeFramebuffer()` function, where we actually resize the `metalLayer.drawableSize`.

Now when we resize our window, it will resize the `metalLayer` accordingly!

# Applying Textures to our Meshes

In order to apply a texture to our mesh, we're going to to need a texture image. You can choose any image you like, but I'll be going with [this one](/images/mc_grass.jpeg). Feel free to use it as well. Once you have your image, create an assets folder in your Xcode project and place your image inside it. Now that we have a texture, we'll need a way to load it in to memory. For this we'll use `stbi_image`, which is a lightweight header-only image loading library. In the `external` directory, create a new folder called `stb`, and right click [this link](https://raw.githubusercontent.com/nothings/stb/master/stb_image.h) and save the header file there. Next, create an implementation file called `stbi_image.cpp` in the same folder and add this code:
````cpp title="stbi_image.cpp"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
````
We now need to instruct Xcode to link with our `stbi_image.cpp` implementation. Go to your Project Settings -> Build Phases -> Compile Sources and add `stbi_image.cpp`.

To load our texture, we'll create a new `Texture()` class. Create two new files in the source directory: `Texture.hpp` and `Texture.cpp`.
````cpp title="Texture.hpp"
#pragma once
#include <Metal/Metal.hpp>
#include <stb/stb_image.h>
class Texture {
public:
    Texture(const char* filepath, MTL::Device* metalDevice);
    ~Texture();
    MTL::Texture* texture;
    int width, height, channels;

private:
    MTL::Device* device;
};
````
We'll define a Constructor that takes in the filepath for the texture image we want to load, as well as our Metal Device so we can copy our image to the GPU as a `MTL::Texture`. We'll also define three public variables width, height, and channels to store the dimensions and number of color channels contained in our loaded image, as well as a handle to our Metal Device.
````cpp title="Texture.cpp"
#include "Texture.hpp"

Texture::Texture(const char* filepath, MTL::Device* metalDevice) {
    device = metalDevice;
    
    stbi_set_flip_vertically_on_load(true);
    unsigned char* image = stbi_load(filepath, &width, &height, &channels, STBI_rgb_alpha);
    assert(image != NULL);
    
    MTL::TextureDescriptor* textureDescriptor = MTL::TextureDescriptor::alloc()->init();
    textureDescriptor->setPixelFormat(MTL::PixelFormatRGBA8Unorm);
    textureDescriptor->setWidth(width);
    textureDescriptor->setHeight(height);

    texture = device->newTexture(textureDescriptor);
    
    MTL::Region region = MTL::Region(0, 0, 0, width, height, 1);
    NS::UInteger bytesPerRow = 4 * width;
    
    texture->replaceRegion(region, 0, image, bytesPerRow);
        
    textureDescriptor->release();
    stbi_image_free(image);
}

Texture::~Texture() {
    texture->release();
}
````
In our `Texture()` constructor, we first set our Metal Device handle, and then we tell stbi to flip our image vertically on load, as Metal expects the 0 coordinate on the y-axis to be on the bottom side of our image, rather than at the top.

We then load our image, make sure the pointer isn't null, and then we create our `MTL::TextureDescriptor`, specifying the Pixel Format of the image, as well as the width and height. We then ask our device to create the texture for us with the specified parameters, and we then copy the image data into the texture buffer. Finally, we release the `textureDescriptor`, and free our `image` buffer. We now have a texture loaded into GPU memory! Hooray. Oh, and don't forget to create your destructor and release the `texture` on destruction.

Now, we'll go back to our `mtl_engine.hpp` and make a few changes:
````cpp title="mtl_engine.hpp" hl_lines="2 3 4 6 18 40 42"
...
#include "VertexData.hpp"
#include "Texture.hpp"
#include <stb/stb_image.h>
...
#include <filesystem>

class MTLEngine {
public:
    void init();
    void run();
    void cleanup();

private:
    void initDevice();
    void initWindow();
    
    void createSquare();
    void createDefaultLibrary();
    void createCommandQueue();
    void createRenderPipeline();
    
    void encodeRenderCommand(MTL::RenderCommandEncoder* renderEncoder);
    void sendRenderCommand();
    void draw();
    
    static void frameBufferSizeCallback(GLFWwindow *window, int width, int height);
    void resizeFrameBuffer(int width, int height);
    
    MTL::Device* metalDevice;
    GLFWwindow* glfwWindow;
    NSWindow* metalWindow;
    CAMetalLayer* metalLayer;
    CA::MetalDrawable* metalDrawable;
    
    MTL::Library* metalDefaultLibrary;
    MTL::CommandQueue* metalCommandQueue;
    MTL::CommandBuffer* metalCommandBuffer;
    MTL::RenderPipelineState* metalRenderPSO;
    MTL::Buffer* squareVertexBuffer;
    
    Texture* grassTexture;
};
````
The first thing to note is our new include files. You'll notice we haven't created `VertexData.hpp` yet, we'll get to that in a moment. We're no longer going to be rendering a triangle. Instead, we'll render a square, so change `createTriangle()` to `createSquare()`, and `triangleVertexBuffer` to `squareVertexBuffer`. Additionally, let's add our `grassTexture` member variable.

````cpp title="VertexData.hpp"
#pragma once
#include <simd/simd.h>

struct VertexData {
    simd::float4 vertex;
    simd::float2 textureCoordinate;
};
````

...
Full write-up soon to come! For now, the code is accessible on the [GitHub repository](https://github.com/wmarti/MetalTutorial/tree/Lesson_1_3) under branch Lesson_1_3, and here is the finished product:

![image](/images/minecraft_texture.png)